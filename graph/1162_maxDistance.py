# -*- coding: utf-8 -*-
'''
# Created on 12-22-22 09:56
# @Filename: 1162_maxDistance.py
# @Desp: 来源于https://leetcode.cn/problems/as-far-from-land-as-possible
# @software: vscode
# @author: xuchang0514@sina.com
'''

# 你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。
# 请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。
# 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。

# 示例 1：
# 输入：grid = [
# [1,0,1],
# [0,0,0],
# [1,0,1]
# ]
# 输出：2
# 解释： 
# 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。

# 示例 2：
# 输入：grid = [
# [1,0,0],
# [0,0,0],
# [0,0,0]
# ]
# 输出：4
# 解释： 
# 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。

# 提示：
# n == grid.length
# n == grid[i].length
# 1 <= n <= 100
# grid[i][j] 不是 0 就是 1

#理解：
# 动态规划 这个是一个错误版本 但是思路上看着是没错的 正确的版本在最后，完了再研究吧

#lib moduls:
import os,sys
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from typing import List

class Solution:

    def __run(self,r,c):

        r0,c0 = r,c
        
        for i in range( 1, max(abs(self.n-r0), r0)+1 ): #扩散的最远偏移量 

            round_dis = []

            for r,c in self.__Sprade(r0,c0,i):

                if 0 <= r < self.n and 0 <= c < self.n and self.grid[r][c] == 1: #没有越界 并且是陆地
                    round_dis.append(self.__manDis(r0,c0,r,c))
                    
            if round_dis != []:
                return min(round_dis) 

        return -1 

    def __manDis(self,x0,y0,x1,y1): #计算两个坐标的曼哈顿距离
        return abs(x0-x1) + abs(y0-y1)

    def __Sprade(self,r,c,i): #返回 [r][c] 位置偏移i之后的坐标组合

        return [[r-i,c],[r+i,c],[r,c-i],[r,c+i],[r+i,c+i],[r+i,c-i],[r-i,c-i],[r-i,c+i]] #返回r c 位置8个方向的坐标

    def maxDistance(self, grid: List[List[int]]) -> int:
        
        mr = len(grid)
        if mr == 0:
            return 0
        mc = len(grid[0])
        self.grid = grid
        self.n = mr
        self.max_distance = -1

        for r in range(mr):
            for c in range(mc):
                if grid[r][c] == 0: #如果是水
                    self.max_distance = max(self.max_distance,self.__run(r,c))

        return self.max_distance

g = [[1,0,0],[0,0,0],[0,0,0]]

# g = [[1,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1,0],
#      [1,0,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0],
#      [1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1],
#      [0,1,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,0],
#      [0,0,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,1,0,0],
#      [0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0],
#      [0,1,0,0,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,0,0,1,1,1,0,1,1],
#      [1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,1,1,0,1,1],
#      [1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,1,0],
#      [1,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,0,0,1,0,1,1,0,1,0,1,1,1],
#      [0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,0],
#      [1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,1,1],
#      [1,1,1,0,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,0,1,1,1,0,1,0],
#      [0,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1],
#      [1,0,1,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,0,1,1,1,1,0,1],
#      [1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,1,0,0,1,1,1],
#      [1,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,1,0,1,0,0,1],
#      [0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1],
#      [1,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,0,1,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0],
#      [1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0],
#      [0,0,0,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,0,1,0,1,0,1,0,0,1,0],
#      [1,1,1,0,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,1,0],
#      [0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0],
#      [0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1],
#      [1,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,1,0,0,1,1,1,0],
#      [0,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0],
#      [0,0,0,1,0,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0],
#      [1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,1],
#      [1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,0,1,1,0,1,0,0,1,0,0,0,1],
#      [0,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0,0,0],
#      [1,1,0,1,1,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,0,1],
#      [0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1],
#      [1,0,0,1,0,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0],
#      [1,0,0,0,1,1,0,1,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,1,0,1],
#      [1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1],
#      [0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
#      [0,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,1],
#      [0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1],
#      [1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1],
#      [1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0]]

s = Solution()
print(s.maxDistance(g))


# class Solution:
#     def maxDistance(self, grid) -> int:
#         n, m = len(grid), len(grid[0])
#         dis = [[float("inf") for j in range(m+2)] for i in range(n+2)]
#         for i in range(1, n+1):
#             for j in range(1, m+1):
#                 if grid[i-1][j-1]:
#                     dis[i][j] = 0
#                 else:
#                     dis[i][j] = min(dis[i-1][j], dis[i][j-1]) + 1
#         res = -1
#         for i in range(n, 0, -1):
#             for j in range(m, 0, -1):
#                 if grid[i-1][j-1]:
#                     dis[i][j] = 0
#                 else:
#                     dis[i][j] = min(dis[i+1][j]+1, dis[i][j+1]+1, dis[i][j])
#                     res = max(dis[i][j], res)
#         return res if res != -1 and res != float("inf") else -1